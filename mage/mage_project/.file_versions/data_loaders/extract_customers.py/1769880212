import base64
import json
from datetime import datetime, timedelta, timezone

import pandas as pd
import requests
from mage_ai.data_preparation.shared.secrets import get_secret_value

if "data_loader" not in globals():
    from mage_ai.data_preparation.decorators import data_loader
if "test" not in globals():
    from mage_ai.data_preparation.decorators import test


def _require_secret(key: str) -> str:
    val = get_secret_value(key)
    if not val:
        raise ValueError(f"Missing required Mage Secret: {key}")
    return val


def _get_base_url() -> str:
    env = _require_secret("QBO_ENV").strip().lower()
    if env == "sandbox":
        return "https://sandbox-quickbooks.api.intuit.com"
    if env in ("prod", "production"):
        return "https://quickbooks.api.intuit.com"
    raise ValueError("QBO_ENV must be 'sandbox' or 'prod'/'production'")


def _refresh_access_token() -> dict:
    client_id = _require_secret("QBO_CLIENT_ID")
    client_secret = _require_secret("QBO_CLIENT_SECRET")
    refresh_token = _require_secret("QBO_REFRESH_TOKEN")

    token_url = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"
    basic = base64.b64encode(f"{client_id}:{client_secret}".encode("utf-8")).decode("utf-8")

    headers = {
        "Authorization": f"Basic {basic}",
        "Accept": "application/json",
        "Content-Type": "application/x-www-form-urlencoded",
    }
    data = {"grant_type": "refresh_token", "refresh_token": refresh_token}

    r = requests.post(token_url, headers=headers, data=data, timeout=30)
    if not r.ok:
        raise RuntimeError(f"Token refresh failed: {r.status_code}\n{r.text}")
    return r.json()


def _qbo_query(access_token: str, realm_id: str, query: str, minorversion: str) -> dict:
    base_url = _get_base_url()
    url = f"{base_url}/v3/company/{realm_id}/query"

    headers = {"Authorization": f"Bearer {access_token}", "Accept": "application/json"}
    params = {"query": query, "minorversion": minorversion}

    r = requests.get(url, headers=headers, params=params, timeout=30)
    if not r.ok:
        raise RuntimeError(
            f"QBO query failed: {r.status_code}\nURL: {r.url}\nBody: {r.text}"
        )
    return r.json()


def _parse_iso_utc(s: str) -> datetime:
    """
    Accepts:
      - 'YYYY-MM-DD'  (assumes 00:00:00 UTC)
      - full ISO 'YYYY-MM-DDTHH:MM:SSZ' or with '+00:00'
    """
    s = s.strip()
    if len(s) == 10:
        dt = datetime.fromisoformat(s).replace(tzinfo=timezone.utc)
        return dt
    # normalize Z
    if s.endswith("Z"):
        s = s[:-1] + "+00:00"
    dt = datetime.fromisoformat(s)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt.astimezone(timezone.utc)


def _iso_z(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")


def _default_window_for_test() -> tuple[datetime, datetime]:
    """
    Default: last 1 day window in UTC (good for testing).
    """
    end_dt = datetime.now(timezone.utc)
    start_dt = end_dt - timedelta(days=1)
    return start_dt, end_dt


@data_loader
def load_data_from_api(*args, **kwargs):
    """
    Backfill Customers from QuickBooks Online with:
      - daily chunking from extract_start_utc to extract_end_utc
      - pagination using STARTPOSITION/MAXRESULTS
      - returns a DataFrame that matches RAW schema for exporter

    You can pass optional kwargs:
      - extract_start_utc: 'YYYY-MM-DD' or ISO UTC
      - extract_end_utc:   'YYYY-MM-DD' or ISO UTC
      - page_size: int

    Or define Mage Secrets (optional):
      - QBO_MINORVERSION (default '75')
      - QBO_PAGE_SIZE (default '200')
      - QBO_EXTRACT_START_UTC / QBO_EXTRACT_END_UTC (optional)
    """
    realm_id = _require_secret("QBO_REALM_ID")

    minorversion = (get_secret_value("QBO_MINORVERSION") or "75").strip()
    page_size = int(kwargs.get("page_size") or (get_secret_value("QBO_PAGE_SIZE") or 200))

    # Determine extraction window
    start_raw = kwargs.get("extract_start_utc") or get_secret_value("QBO_EXTRACT_START_UTC")
    end_raw = kwargs.get("extract_end_utc") or get_secret_value("QBO_EXTRACT_END_UTC")

    if start_raw and end_raw:
        extract_start = _parse_iso_utc(start_raw)
        extract_end = _parse_iso_utc(end_raw)
    else:
        extract_start, extract_end = _default_window_for_test()

    if extract_end <= extract_start:
        raise ValueError("extract_end_utc must be greater than extract_start_utc")

    token_payload = _refresh_access_token()
    access_token = token_payload["access_token"]

    # If Intuit rotates refresh_token, warn you
    new_refresh_token = token_payload.get("refresh_token")
    if new_refresh_token:
        old_refresh_token = _require_secret("QBO_REFRESH_TOKEN")
        if new_refresh_token != old_refresh_token:
            print("âš ï¸ Intuit returned a NEW refresh token.")
            print("ðŸ‘‰ Update Mage Secret QBO_REFRESH_TOKEN to avoid future failures.")

    rows = []

    # Chunk daily: [day_start, day_end)
    day_cursor = extract_start.replace(hour=0, minute=0, second=0, microsecond=0)
    final_end = extract_end

    while day_cursor < final_end:
        day_start = max(day_cursor, extract_start)
        day_end = min(day_cursor + timedelta(days=1), final_end)

        # QBO query uses MetaData.LastUpdatedTime for incremental/backfill filtering
        # Format: 'YYYY-MM-DDTHH:MM:SSZ'
        where_clause = (
            f"WHERE MetaData.LastUpdatedTime >= '{_iso_z(day_start)}' "
            f"AND MetaData.LastUpdatedTime < '{_iso_z(day_end)}'"
        )

        # Pagination: STARTPOSITION is 1-based in QBO
        start_position = 1
        page_number = 1

        while True:
            q = (
                "SELECT * FROM Customer "
                f"{where_clause} "
                f"STARTPOSITION {start_position} MAXRESULTS {page_size}"
            )

            payload = _qbo_query(access_token, realm_id, q, minorversion)
            customers = (payload.get("QueryResponse", {}) or {}).get("Customer", []) or []

            request_payload = {
                "entity": "Customer",
                "query": q,
                "minorversion": minorversion,
                "realm_id": realm_id,
                "env": _require_secret("QBO_ENV"),
            }

            # Build DF rows matching RAW contract
            for c in customers:
                cid = c.get("Id")
                if cid is None:
                    continue
                rows.append({
                    "id": str(cid),
                    "payload": json.dumps(c),
                    "extract_window_start_utc": _iso_z(day_start),
                    "extract_window_end_utc": _iso_z(day_end),
                    "page_number": page_number,
                    "page_size": page_size,
                    "request_payload": json.dumps(request_payload),
                })

            # Stop paging if no results or last page
            if len(customers) < page_size:
                break

            start_position += page_size
            page_number += 1

        day_cursor = day_cursor + timedelta(days=1)

    return pd.DataFrame(rows)


@test
def test_output(output, *args) -> None:
    assert output is not None, "Output is undefined"
    assert hasattr(output, "shape"), "Output is not a DataFrame-like object"
    # Output can be empty if that date window truly has no updates; that's OK.
    if output.shape[0] > 0:
        required_cols = {
            "id",
            "payload",
            "extract_window_start_utc",
            "extract_window_end_utc",
            "page_number",
            "page_size",
            "request_payload",
        }
        missing = required_cols - set(output.columns)
        assert not missing, f"Missing expected columns: {missing}"
